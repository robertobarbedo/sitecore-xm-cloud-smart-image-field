# üîí Security Model

## Overview

The security model uses **application-level security** rather than database-level Row Level Security (RLS). This approach is appropriate because:

1. ‚úÖ Access is controlled via URL parameters (`organizationId` and `key`)
2. ‚úÖ The application validates these on every request
3. ‚úÖ Sitecore Marketplace validates the user's access before loading the app
4. ‚úÖ No direct database access - all queries go through your Next.js API

## Row Level Security (RLS) Configuration

### Current Setup

RLS is **enabled** on the `image_metadata` table, but with **permissive policies**:

```sql
-- Policy for anonymous (anon) users
CREATE POLICY "Allow all operations for anon users"
    ON image_metadata
    FOR ALL
    TO anon
    USING (true)
    WITH CHECK (true);

-- Policy for authenticated users
CREATE POLICY "Allow all operations for authenticated users"
    ON image_metadata
    FOR ALL
    TO authenticated
    USING (true)
    WITH CHECK (true);
```

### Why Permissive Policies?

The policies allow all operations because:

1. **Application Controls Access** - Your Next.js app enforces security:
   ```typescript
   const params = getUrlParams(); // Gets organizationId and key from URL
   await upsertImageMetadata({
       organization_id: params.organizationId,  // Only this org's data
       key: params.key,                        // Only with valid key
       // ...
   });
   ```

2. **Sitecore Validates Users** - Before your app loads, Sitecore Marketplace:
   - Authenticates the user
   - Validates their permissions
   - Generates unique `key` and `organizationId`
   - Passes these in the URL

3. **No Public Access** - The app is only accessible:
   - When embedded in Sitecore
   - With valid URL parameters
   - To authenticated Sitecore users

## Security Layers

### Layer 1: Sitecore Marketplace (Primary)
- ‚úÖ User authentication
- ‚úÖ Permission validation
- ‚úÖ Generates secure keys
- ‚úÖ Controls app loading

### Layer 2: Application Logic (Secondary)
- ‚úÖ Validates URL parameters exist
- ‚úÖ Includes `organizationId` and `key` in all queries
- ‚úÖ Filters results by organization

### Layer 3: Database (Tertiary)
- ‚úÖ RLS enabled (defense in depth)
- ‚úÖ Composite unique keys prevent duplicates
- ‚úÖ Audit trail via timestamps

## Data Isolation

Each organization's data is isolated through:

### Unique Constraint
```sql
UNIQUE(organization_id, key, image_item_id)
```

This ensures:
- Organizations can't overwrite each other's data
- Each org has separate records
- Keys provide additional isolation

### Query Filtering

All queries include filters:

```typescript
// Search example
await searchImagesByText(
    organizationId,  // ‚Üê Filters to this org only
    key,            // ‚Üê Additional filter
    searchQuery,
    limit
);

// Get image example
await getImageByItemId(
    organizationId,  // ‚Üê Filters to this org only
    key,            // ‚Üê Additional filter
    imageItemId
);
```

## URL Parameters

### Required Parameters

Every request must include:

```
http://localhost:3000/?organizationId=org_xxx&key=xxx
```

- **organizationId** - Unique identifier for the organization
- **key** - Session key generated by Sitecore
- Both are validated and used in all database operations

### How They're Used

```typescript
// Extract from URL
const params = getUrlParams();

if (!params) {
    // No valid params ‚Üí Skip database operation
    console.warn('Missing URL params');
    return;
}

// Use in all operations
await upsertImageMetadata({
    organization_id: params.organizationId,  // From URL
    key: params.key,                        // From URL
    // ... other fields
});
```

## API Key Security

### Anon Key is Safe

The `NEXT_PUBLIC_SUPABASE_ANON_KEY` in `.env.local` is safe to use because:

1. ‚úÖ **Rate limited** - Supabase limits requests
2. ‚úÖ **RLS enabled** - Database has security policies
3. ‚úÖ **Application filtering** - Your code filters by org/key
4. ‚úÖ **Read-only for public** - Can only read data you explicitly allow
5. ‚úÖ **No admin access** - Cannot modify database schema

### What the Anon Key Can Do

With the current setup, someone with the anon key could:
- ‚ùå Read all records (if they bypass your app)
- ‚ùå Write records (if they bypass your app)

**BUT** - This is acceptable because:
- The app is only accessible through Sitecore (not public)
- Sitecore validates users before loading the app
- URL parameters are unique per session
- Your application code filters all queries

### Enhanced Security (Optional)

If you need stronger security, you could:

1. **Add API route protection**:
   ```typescript
   // pages/api/images.ts
   export default async function handler(req, res) {
       // Validate organizationId and key
       const { organizationId, key } = req.query;
       
       if (!isValidSession(organizationId, key)) {
           return res.status(401).json({ error: 'Unauthorized' });
       }
       
       // Proceed with database operation
   }
   ```

2. **Use service role key server-side**:
   ```typescript
   // Only in API routes, never expose to client
   const adminClient = createClient(
       process.env.SUPABASE_URL,
       process.env.SUPABASE_SERVICE_ROLE_KEY // Server-side only
   );
   ```

3. **Add JWT validation**:
   ```typescript
   // Validate Sitecore's JWT token
   const token = req.headers.authorization;
   const isValid = await validateSitecoreToken(token);
   ```

## Best Practices

### ‚úÖ DO

- Always include `organizationId` and `key` in queries
- Validate URL parameters before database operations
- Log database operations for audit trails
- Use the provided helper functions (they include filtering)

### ‚ùå DON'T

- Don't expose service role key to the client
- Don't skip organization/key filtering
- Don't allow users to specify their own organizationId
- Don't trust client-side data without validation

## Monitoring

### Check for Unauthorized Access

```sql
-- View all organizations in database
SELECT DISTINCT organization_id, COUNT(*) 
FROM image_metadata 
GROUP BY organization_id;

-- Check for suspicious patterns
SELECT organization_id, key, COUNT(*) as image_count
FROM image_metadata
GROUP BY organization_id, key
ORDER BY image_count DESC;
```

### Audit Trail

All records include:
- `created_at` - When record was created
- `updated_at` - When record was last modified

```sql
-- Recent activity
SELECT organization_id, key, created_at, updated_at
FROM image_metadata
ORDER BY updated_at DESC
LIMIT 100;
```

## Summary

| Security Layer | Implementation | Status |
|----------------|----------------|--------|
| Sitecore Auth | Marketplace validates users | ‚úÖ Active |
| URL Parameters | organizationId + key required | ‚úÖ Active |
| Application Filter | All queries include org/key | ‚úÖ Active |
| RLS Policies | Permissive for anon/auth | ‚úÖ Active |
| Composite Keys | Prevent data collisions | ‚úÖ Active |
| Audit Trail | Timestamps on all records | ‚úÖ Active |

**Security Model: Application-level with defense in depth** ‚úÖ

The current setup provides adequate security for a Sitecore Marketplace extension while maintaining simplicity and performance.

